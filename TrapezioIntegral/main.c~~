#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <time.h>

double avaliaFuncao (double x)
{
	return (x*x);
}

double Trap (double local_a, double local_b, double local_n, double h)
{
	int i;
	double aprox, x_i;
	aprox = (avaliaFuncao(local_a) + avaliaFuncao(local_b))/2.0;
	for (i = 1; i <= local_n-1; i++)
	{
		x_i = local_a + i*h;
		aprox += avaliaFuncao(x_i);
	}
	aprox = h*aprox;
	return (aprox);
}

int main ()
{
	clock_t t;
	int my_rank, comm_sz, n = 10000000, local_n;
	double a = 0.0, b = 3.0, h, local_a, local_b;
	double local_int, total_int;
	int source;
	
	MPI_Init(NULL,NULL);
	MPI_Comm_rank(MPI_COMM_WORLD,&my_rank);			// Qual meu id
	MPI_Comm_size(MPI_COMM_WORLD,&comm_sz);			// Quantos processos foram disparados

	if (my_rank == 0)
		t = clock();

	h = (b-a)/n;
	local_n = n/comm_sz;
	
	local_a = a + my_rank*local_n*h;			// Calcula o inicio do intervalo do processo.
	local_b = local_a + local_n*h;				// Calcula o fim do intervalo do processo.
	local_int = Trap(local_a,local_b,local_n,h);		// Calcula a integral do processo, isto é um valor parcial do total.

	// Enviar o cálculo da integral parcial para o mestre, caso o processo seja escravo
	if (my_rank != 0)
		MPI_Send(&local_int,1,MPI_DOUBLE,0,0,MPI_COMM_WORLD);
	// Caso mestre, acumular todas as integrais parciais.	
	else
	{
		int source;
		total_int = local_int;
		// Receber as mensagens dos escravos na ordem
		for (source = 1; source < comm_sz; source++)
		{
			MPI_Recv(&local_int,1,MPI_DOUBLE,source,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE);
			total_int += local_int;
		}
		if (my_rank == 0)
		{
			t = clock() - t;
			printf("Com n = %d trapezios a integral vale:\n",n);
			printf("De %lf ate %lf = %e\n",a,b,total_int);
			printf("Duracao: %e segundos\n", ((double)t)/CLOCKS_PER_SEC);
		}
	}	
	MPI_Finalize();
	return (0);
}
